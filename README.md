# Freer Monads, More Extensible Effects
# Oleg Kiselyov, Hiromi Ishii     

## Haskell’15, September 3-4, 2015, Vancouver, BC, Canada

(примечание переводчика: в тексте фигурируют как свободные (Free) монады, так и Freer, которые я неточно перевожу как «свободнейшие». Так же, присутствуют сокращения. По большей части убраны отсылки к другим статьям. )

## Реферат

Мы представляем рациональную реконструкцию расширяемых эффектов (extensible effects) – недавно предложенную альтернативу монадным трансформерам, как результат слияния усилий для достижения эффективности вычислений. Свободные монады, вместе с расширяемыми эффектами дают перспективу к эффективным вычислениям наиболее абстрактным путём. Процесс дальнейшего обобщения приводит к свободнейшим монадам, без использования ограничения Functor. Продолжая рассматривать свободнейшие монады можно прийти к эффективным, упорядоченным по типу, структурам данных. Конечным результатом стала библиотека алгоритмически эффективных расширяемых эффектов, которая не только более понятна, но и быстрее, чем её ранние реализации. В качестве иллюстрации к новой библиотеке, мы показываем три удивительно простые приложения: недетерминизм с совершенным выбором (LogicT), захват IO исключений в присутствии других эффектов, и полу-автоматическое управление файловыми дескрипторами и другими ресурсами используя монадные регионы. Мы широко используем и пропагандируем новый вид «лени», в основе которой лежит левое расширение Кана : вместо выполнения операций, сохранить эти операции делая вид что они выполнены.

## 1. Введение

То, что монады не сочетаются, было признано проблемой почти сразу. Два независимо написанных выражения, использующих разные побочные эффекты (и, следовательно, монады), трудно совместить в одной программе. Изменение небольшой части большой программы, для добавления нового побочного эффекта (например, добавление отладочного вывода) приводит к необходимости внесения ряби мелких изменений по всему коду. Трудность добавления и объединения эффектов следует из денотационной семантики. В самом деле, монады, введённые Moggi как способ структурирования денотационной семантики унаследовали эту проблему. Можно выделить три подхода к решению. Наиболее популярный, это монадные трансформеры, реализованные в библиотеке monad transformer library (mtl). Они основаны на оригинальной идее Moggi о "монадах с дыркой" (“monads with a hole”), добавляя к ней операцию поднятия монад сквозь стек трансформеров. Второй подход сочетает в себе монады и довольно сложной coproduct, что привело к популяризации свободных монад в известной статье «Data types `a la carte». Третий, представленный ещё до монадных трансформеров, предусматривает эффекты как взаимодействия и реализация сторонних эффектов запросом к обработчикам. Эта идея обработчиков эффектов, обобщая её на обработчики исключений, была подхвачена и разработана в языке Eff. В Haskell, такой подход был реализован в ранних библиотеках расширяемых эффектов. 

Во второй части мы представим унифицированное представление вычислений с эффектами из свободной монады и расширяемых эффектов постепенно абстрагируясь от прямолинейного представления. Расширенные эффекты (extensible effects) являются сочетанием идей свободных монад с открытыми объединениями (open union). Такое объединение в рациональную конструкцию не просто поучительно. Оно приведёт к дальнейшему обобщению, показанному в разделе 2.4: свободнейшие монады, свободные даже от ограничений класса типов Functor. Свободнейшая монада – это алгебраический тип данных, который является монадой по конструкции, так же, как список – это моноид по конструкции. Кроме интеллектуального удовлетворения, использование свободнейших монад даёт экономию памяти, избегая восстановления структуры данных запроса на каждой операции связывания. 

Третья часть описывает улучшенную библиотеку расширяемых эффектов, а четвёртая часть демонстрирует улучшенную производительность на нескольких тестах по сравнению с mtl и другими библиотеками обработчиков эффектов.

Наш вклад, таким образом, имеет реальное применение. Это история о свободнейшей монаде, которая поддерживает простое добавление, сочетание и вычитание (то есть, инкапсуляцию) эффектов. Мы демонстрируем выразительность на трех применениях, которые ранее считались трудно расширяемыми с помощью эффектов или монад в целом. В части пять мы покажем исключительно простую реализацию не-детерминизма совершенного выбора (The LogicT монада). В части шесть представим удивительно простую реализацию обработки ошибок IO не в монаде IO. Не в монаде IO исключения ведут себя не как IO исключения в отношении других эффектов (например State). Наконец, в части семь, демонстрируется, окончательный эффект инкапсуляции: монадные регионы, новое представление и упрощение библиотеки основанной на трансформерах. Полный код доступен по адресу http://okmij.org/ftp/Haskell/extensible/Eff1.hs.

## 2. Выведение свободнейших монад

В этой части мы выводим свободнейшие и расширяемые монады постепенно избавляясь от шаблонного представления об эффектах. Результат получится элегантным, но с плохой производительностью, которую мы улучшим в части 3.

### 2.1 Reader эффект

Мы начнём с простейшего стороннего эффекта: динамического связывания, или Reader в терминологии mtl. Reader вычисления зависят от значения поддерживаемого окружением, то есть, его контекстом. Вообще, сторонний эффект можно понимать как взаимодействие выражения с контекстом. Возможные запросы могут быть определены типом данных, который в нашей случае

```Haskell
Data It i a = Pure a
         	| Get (i -> It i a)
```	
Такое алгебраическое моделирование возможных операций было впервые введено в Haskell Хьюзом (Hughes) и теперь известно в Haskell как ‘operational’. Выражение  Pure a обозначает вычисление a, не делающего никаких запросов. Запрос Get к запрашивает контекст для текущего, динамически связаного значения типа i. Получив значение i, вычисление k i :: It i a  продолжается, возможно, запрашивая больше значений из контекста. То есть, можно называть вызов Get к продолжением. Простейшее запрашиваемое вычисление, это

```Haskell
ask :: It i i
ask = Get Pure
```
которое немедленно возвращает принятое значение. Сложные вычисления строятся с помощью монадного связывания – (>>=):It i – это монада.

```Haskell
instance Monad (It i) where
-- return :: a -> It i a
return = Pure
-- (>>=) :: It i a -> (a -> It i b) -> It i b
Pure x >>= k = k x
Get k' >>= k = Get (k' >>> k) 
```
Последняя строка означает, что вычисление ожидает входные данные, затем продолжается, как k', а следом как k, т.е. вычисление, которое продолжается после ожидания композиции k'и k. Оператор (>>>), это композиция Kleisli, или композиция функций с эффектами:

```Haskell
(>>>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
f >>> g = (>>= g) . f
```
Приведём два примера усложнённых Reader вычислений

```Haskell
addGet :: Int -> It Int Int
addGet x = ask >>= \i -> return (i +x)
addN :: Int -> It Int Int
addN n = foldl (>>>) return (replicate n addGet) 0
```
Последний пример спрашивает число n раз и возвращает сумму.
Вычисления addGet и addN делают запросы к контексту. Нам необходимо определить как отвечать, то есть, как выполнить (run) эти вычисления. Следующий интерпретатор даёт одинаковое значение i на каждый запрос: It i a на самом деле интерпретируется как монада Reader.

```Haskell
runReader :: i -> It i a -> a
runReader (Pure v) = v
runReader x (Get k) = runReader x (k x)
```
В отличии от mtl Reader-а, It i a может трактоваться различно, например, каждый запрос может давать новое значение, как если бы происходило чтение из потока:
```Haskell
feedAll :: [ i ] -> It i a -> a
feedAll _ (Pure v) = v
feedAll [] = error "end of stream"
feedAll (h : t) (Get k) = feedAll t (k h)
```
В такой интерпретации It i a называется iteratee, а feedAll перечислитель (enumerator).

### 2.2 Reader/Writer эффект

Давайте добавим другой эффект: Writer, или трассирующий эффект.

```Haskell
data IT i o a = Pure a
	           | Get (i -> IT i o a)
	           | Put o (() -> IT i o a)

```
Запрос Put o k устанавливает значение o контекста. После того, как установка контекста подтверждена возвратом (), вычисление продолжается как к (). Расширенный IT i o, так же, является монадой:

```Haskell
instance Monad (IT i o) where
	return = Pure
	Pure x >>= k = k x
	Get k' >>= k = Get (k' >>> k)
	Put x k' >>= k = Put x (k' >>> k)
```	
И, снова, вычисление, которое устанавливает контекст и продолжается как k', а затем как k, является продолжением k' >>> k.
В mtl монаде Writer, сообщаемое значение должно быть моноидом. Наш IT i o не имеет таких ограничений. Если мы напишем Writer-подобный IT интерпретатор, то должны накапливать значения, и должны будем ввести ограничение типа на Monoid:

```Haskell
runRdWriter :: Monoid o => i -> IT i o a -> (a, o)
runRdWriter i m = loop mempty m
	where
		loop acc (Pure x) = (x,acc)
		loop acc (Get k) = loop acc (k i )
		loop acc (Put o k) = loop (acc `mappend` o) (k ())
```
Есть другие пути интерпретации IT i o запросов, например, сохранять последнее установленное значение или выводить его в stderr. В ещё одном варианте интерпретатора, IT s s, вычисление сделанное с сохранением контекста, даёт следующее запрашиваемое значение контекста, т.е.,  IT s s может работать как State.
IT i o вычисление, это расширение IT i. Увы, типы данных не расширяемы. Следовательно, мы должны изменить имя типа данных и, соответственно, сигнатуры addGet и addN даже если их код не зависит от добавленного эффекта, и, по сути, тот же.

### 2.3 Свободная монада

Тип данных, описываемый в вычислениях с эффектами, такой как It i a или  IT i o следуют общему шаблону: это рекурсивный тип данных, в которым вариант Pure применяемый при отсутсвии каких либо запросов, и варианты запросов, как правило, содержащие продолжение, которое получаетответ (кроме исключений, которые не ожидают никакого ответа). Используются рекурсивные вхождения типа данных всегда в качестве возвращаемого значения, то есть в ковариантных позициях. Этот шаблон, с чистым (Pure) вариантом, и ковариантным рекурсивным вариантом с эффектом может быть представлена как

```Haskell
data Free f a = Pure a
	            | Impure (f (Free f a))
```
Где f является (категорическим) функтором, то есть, для f a тип a используется ковариантно. Последняя фраза означает, что если мы можем конвертировать значение типа а в значение типа b, то мы можем, так же конвертировать f a  в  f b. Класс типов Functor трактует это буквально:

```Haskell
class Functor f where
	fmap :: (a -> b) -> (f a -> f b)
```
Конкретные экземпляры (instantiations) f определяют типы запросов и ответов, то есть, эффект конкретного вычисления с эффектами. 

Экземпляры (instances) монад для It i a и IT i o также имеют много общего. Жаль, писать такие экземпляры для каждого нового эффекта и каждой комбинации эффектов. Тип данных Free f позволит нам вывести общий шаблон:

```Haskell
instance Functor f => Monad (Free f) where
	return = Pure
	Pure a >>= k = k a
	Impure f >>= k = Impure (fmap (>>= k) f)
```
Free f для функтора f – это монада, свободная монада. Новые эффекты будут иметь свои описания, но один экземпляр (instance)   Monad (Free f) будет работать для все их, без дальнейшего переписывания.

В качестве примера, ранее определённое вычисление  IT i o мы можем сейчас переписать как

```Haskell
data ReaderWriter i o x = Get (i -> x) | Put o (() -> x)
instance Functor (ReaderWriter i o) where ...
type IT i o a = Free (ReaderWriter i o) a
```
Слово «Free» в свободной монаде – отсылка к теории категорий, где она понимается как левое сочетание забывающей операции (Разные трактовки свободной монады от нескольких Haskell-гуру можно почитать здесь : http://stackoverflow.com/questions/13352205/what-are-free-monads. Прим. переводчика). То есть, если мы возьмём монаду, скажем, State s, с return, bind, fmap, put и get операциями, и забудем первые две, то мы сможем восстановить монаду как Free (State s), с протезированием return и bind. 

В общем, то монады не сочетаются: если M1 a и M2 a – монады, то M1 (M2 a), в общем случае, не монада. Свободные монады, однако, являются особой формой монады, определённой через функтор. А функторы сочетаются. Мы будет использовать этот факт, после еще одного обобщения.

### 2.4 Свободнейшие монады

Давайте посмотрим более внимательно на экземпляр монады для Free f. Задача fmap здесь – продлить продолжение втроенное где то в (f (Free f a)) при помощи (>>>)-композиции с новым k. Операция fmap позволяет нам, в общем виде, модифицировать встроенное продолжение для любого вида запроса. Так как аргумент продолжения обрабатывается единообразно, имеет смысл вывести его из описания запроса и поместить справа, в фиксированную структуру данных запроса, как второй аргумент  Impure.

```Haskell
data FFree f a where
	Pure :: a -> FFree f a
	Impure :: f x -> (x -> FFree f a) -> FFree f a
```
Оставшаяся часть сигнатуры запроса f x указывает на тип ответа x, который должен быть подан в продолжение. Различные запросы имеют их собственные типы ответов, отсюда х должен быть  existentially quantified. Наш  Reader-Writer эффект даёт следующую сигнатуру:

```Haskell
data FReaderWriter i o x where
	Get :: FReaderWriter i o i
	Put :: o -> FReaderWriter i o ()
```
Экземпляр переменной типа x в FReaderWriter i o x зависит от типа запроса. Для Get, тип ответа I, а для Put тип ответа (). Ранее описанный тип IT i o a становится

```Haskell
type IT i o a = FFree (FReaderWriter i o) a
```
Экземпляру монады 	FFree f становится больше не нужен Functor или какой либо другой ограничитель (constraint) переменной типа f:

```Haskell
instance Monad (FFree f) where ...
   Impure fx k' >>= k = Impure fx (k' >>> k)
```
FFree f становится более подходящей, т.к. абстрагируется более общей моделью накомпления продолжений, по сравнению с Free. Это более общая, не накладывающая никаких ограничений на f, ещё более свободная монада - “freer” ("свободнее") (выше и ниже по тексту свободнейшая. Прим. переводчика). Продолжая наш пример с State s из конца пункта 2.3, мы можем сейчас забыть не только return и bind, но, так же и fmap, и, всё ещё сможем восстановить монаду состояния из конструкции FFree (State s). Мы не должны больше определять основные монадные и функторные операции вначале: мы можем сейчас свободно получать не только экземпляр Monad, но и экземпляры Functor и Applicative. Свободнейшая монада, так же, более экономна по памяти и времени выполнения, потому что продолжение может сейчас быть доступно непосредственно, а не через fmap, который должен был восстанавливать струтуру отображения. Явное продолжение FFree, так же упрощает изменение его представления, которое мы рассмотрим в части 3. Marcelo Fiore предположил в частной беседе, что конструкция FFree является левым расширением Kan. Чтобы подчеркнуть это мы покажем другой вывод FFree. Вспомним, если f :: * -> * это функтор, тогда мы можем преобразовать f x в f a, то мы можем отобразить значения x в значения a.  Если g :: * -> * не функтор, то такое преобразование невозможно. Мы можем, однако, схитрить: хоть мы и не можем, по настоящему использовать fmap на h :: x -> a через g x, мы можем сохранить эти две операции как пару и полагать, как если бы отображение выполнялилось:

```Haskell
data Lan (g :: * -> *) a where
	FMap :: (x -> a) -> g x -> Lan g a 
```
Любое дальнейшее отображение (mapping) через Lan g a обновляет оригинальное отображение, оставляя g x нетронутым. Так что Lan g становится «формально» функтором.

```Haskell
instance Functor (Lan g) where
	fmap h (FMap h' gx) = FMap (h . h') gx
```
Эта Lan конструкция есть Левое Kan расширение (Left Kan extension). Можно думать, что это свободный Haskell Functor – Functor по конструкции.

Мы можем видеть что Free (Lan g) при подстановке вместо f в конструктор Impure, заменяя в

```Haskell
(f (Free f a)) -> Free f a  
```
f на  Lan g получаем

```Haskell
forall x. (x -> (Free (Lan g) a)) -> g x -> Free (Lan g) a
```
а это тип FFree.Impure, то есть

```Haskell
type FFRee g = Free (Lan g)
```
Кстати, выровненные по типу последовательности (type aligned sequences – гетерогенные последовательности, в которых тип определяет упорядоченность последовательности. прим. переводчика), которые мы будем использовать в части 3, по существу свободные (Free-er) Applicative. По аналогии со свободным функтором (“free functor”) Lan g мы можем также определить как свободный бифунктор.

```Haskell
data BiFree p a b where
	Bimap :: (a -> b) -> (c -> d) -> p a c -> BiFree p b d
```
Остался один шаг обобщения, для получения обещанной расширяемости.

### 2.5 Из свободнейших монад к расширяемым эффектам

Мы намекнули в п.2.3, что форма свободных монад, построенный из функторов, поддается композиции, так как функторы сочетаются. В этом разделе демонстрируется компонуемость свободнейших (freer) монад используя левое расширение Kan, которое является по конструкции функтором. Есть две стороны к композиции: расширяемый тип монады и модульные интерпретаторы. Монадный тип является расширяемым , если мы можем добавить новый эффект, без необходимости прикасаться или даже перекомпилировать старый код. Free f и FFree f позволяют индексировать монадный тип по сигнатуре запроса. Спецификация сигнатуры как обычного типа, вроде ReaderWriter из п.2.3 или FReaderWriter из п.2.4 не расширяемы. Обычный, вариантный тип данных, это закрытое объединение (closed union), в котором фиксированное число вариантов. Открытое объединение (open union) относительно легко строить, по существу, путём вложения простейших объединений, вроде типа Either. Мы будем использовать улучшенное открытое объединение (open union). Оно предполагает (абстрактный) тип Union (r :: [*->*]) x где первый аргумент r – это  уровня типов (type-level) список меток эффектов. Второй аргумент – тип ответа, который зависит от конкретного запроса. Аргумент r – список всех эффектов, возможных в вычислении. Конкретное значение Union r x содержит один запрос из перечисленных в r. Это имеет решающее значение для расширяемости, чтобы можно было иметь возможность связываться с одним эффектом без необходимости перечислять все остальные. Ради этого эффекта полиморфизма, наша реализация обеспечивает класс типа

```Haskell
class Member t r where
	inj :: t v -> Union r v
	prj :: Union r v -> Maybe (t v)
```
что служит для подтверждения, что метка t находится в списке r. Если эффект является частью
union, его запрос может быть введен (injected - inj) и извлечён (обратная операция, projected – prj). Мы также предлагаем функцию «ортогональной проекции» из объединения.

```Haskell
decomp :: Union (t ': r ) v -> Either (Union r v) (t v)
```
-получение либо запроса по метке t, либо уменьшенного объединения, без t.

Эта функция необходима для инкапсуляции эффекта. Ранняя библиотека расширяемых эффектов предполагала простейшее открытое объединение, реализуемое через overlapping instances и Typeable. Последнее, в частности, имеется большое количество жалоб. Текущая реализация не использует ни  overlapping, ни Typeable. И, так же, не предполагает, необходимость в экземплярах Functor. Расширяемая свободнейшая монада, монада расширяемых эффектов, это FFree c открытым объединением:

```Haskell
data FEFree r a where
	Pure :: a -> FEFree r a
	Impure :: Union r x -> (x -> FEFree r a) -> FEFree r a
```	
Запрашиваемая метка определяет подходящий эффект и его запрос. Для примера, Reader и Writer эффекты имеют следующие метки:

```Haskell
data Reader i x where
	Get :: Reader i i
data Writer o x where
	Put :: o -> Writer o ()
```
Мы разделили запрос FReaderWriter на компоненты, комбинируемые в открытом объединении.

Простейшее Reader вычисление, ask из п.2.1, теперь записывается так:

```Haskell
ask :: Member (Reader i) r => Eff r i
ask = Impure (inj Get) return
```
Сигнатура говорит, что ask это Eff r i вычисление, которое включает Reader i эффект без уточнения что другие эффекты тоже могут быть представлены. В отличие от старой ask из п.2.1, новый может быть использован как есть, без каких либо выравниваний кода или сигнатуры, в программе с другими эффектами.

### 2.6 Проблема производительности свободнейших монад 

Свободные и свободнейшие монады безусловно элегантны но неэффективны. Посмотрим снова на экземпляр монады FFree f

```Haskell
instance Monad (FFree f) where ...
	Impure fx k' >>= k = Impure fx (k' >>> k)
```
Операция привязки просто передаёт левый аргумент, и выполняет композицию операций лишь для правого аргумента. Таким образом, производительность лево ассоциированных связываний, подобно лево ассоциированных добавлений в списки, будет плохой - алгоритмически медленной. Например, выполнение addN n раз, реализованной и как обычная монада, и как FEFree [Reader i] монада будет квадратичной от n. Это потому что addN получилась ассоциативной к addGet слева. Для примера, addN 3 эквивалентна

```Haskell
((( return >>> addGet) >>> addGet) >>> addGet) 0
```
которая делается в три шага

```Haskell
(( Impure (inj Get) return >>> (+0)) >>= addGet) >>= addGet
```
Два вычисления связываются и затем производят конечный результат

```Haskell
Impure (inj Get) (( return >>> (+0) >>> addGet x) >>> addGet)
```
Продолжение, второй аргумент Impure, это цепочка из addGet. Обработка ответа из контекста будет снова линейна по времени размеру цепочки. В целом, обработка запросов занимает O (n^2) времени. Это проблема производительности, и в общем случае, представления продолжений как эффективных структур данных последовательности, выровненной по типам (type-aligned sequence).

## 3. Конечный результат: Свободнейшая (Freer) и лучшая расширяемых эффектов Eff монада

Эта часть описывает нашу текущую, улучшенную и эффективную библиотеку расширяемых эффектов. Благодаря Freer монаде и новому открытому объединению (open union), стало проще, по сравнению с версией, представленной два года назад, определять определять новые эффекты и писать их обработчики. Производительность, алгоритмически, так же улучшилась. Перед демонстрацией библиотеки в п3.2 мы опишем последнее ключевое улучшение, представление продолжения в качестве эффективной структуры данных.

### 3.1  Составные продолжения как структуры данных

Новая библиотека основана на монаде FEFree выведенной в п.2.5 (повторим здесь для наглядности):

```Haskell
data FEFree r a where
	Pure :: a -> FEFree r a
	Impure :: Union r x -> (x -> FEFree r a) -> FEFree r a
```
Отличающееся в одном, последнем, отношении: сейчас  продолжение запроса открыто x -> FEFree r a , оно может быть не только функцией. Мотивацией для нового представления стал взгляд на экземпляр монады FEFree f

```Haskell
instance Monad (FFree f) where ...
	Impure fx k' >>= k = Impure fx (k' >>> k)
```
Который расширяет продолжение запроса k’ новым сегментом k. Пример из [A. van der Ploeg and O. Kiselyov. Reflection without remorse: revealing a hidden sequence to speed up monadic reflection. (Безжалостное отражение: выявление скрытой последовательности для ускорения монадического отражения) In Haskell [12], pages 133–144.] представляет эту концептуальную последовательность расширений с всё большим и большим количеством сегментов в одну последовательность. Она будет содержать все, какие нужно, сегменты, фактически не составляя их! Вскоре мы увидим, что композиция, на самом деле, не нужна: это был просто способ накопления сегментов продолжений и он не является эффективным. (Другая причина для поиска новых представлений продолжений – это проблема производительности свободных (free) и свободнейших (freer) монад, описанный в п.2.6.)

Мы будем называть улучшенную FEFree r монаду Eff r, где r, как и в п.2.5 – список меток эффектов. Продолжение запроса, которое получает ответ x и, отвечает а – это тип x -> Eff r a . Мы определим удобный тип аббревиатуру для таких функций с эффектом, так что, функциональное отображение a в b , которое так же делает эффект r, обозначим.

```Haskell
type Arr r a b = a -> Eff r b
```
Задача монадного связывания аккумулировать продолжения запросов при помощи композиции (>>>) с всё новыми и новыми Arr r a b сегментами. Вместо настоящего выполнения композиции, мы только предполагаем выполнение и лишь накапливаем кусочки, собираемые в структуру данных. Левое расширение Kan делает такой же трюк с «делаем вид что операция выполняется». Структура данных, действительно гетерогенная, упорядоченная по типу. В Arr r a b ,  a и b должны быть разного типа, и тип результата предыдущей функции должен соответствовать типу аргумента следующей. Упорядоченные по типу последовательности соблюдают это требование при построении. Мы выбрали последовательность FTCQueue, имеющую следующий интерфейс

```Haskell
type FTCQueue (m :: * -> * ) a b
tsingleton :: (a -> m b) -> FTCQueue m a b
(|>) :: FTCQueue m a x -> (x -> m b) -> FTCQueue m a b
(|><|) :: FTCQueue m a x -> FTCQueue m x b -> FTCQueue m a b

data ViewL m a b where
	TOne :: (a -> m b) -> ViewL m a b
	(:|) :: (a -> m x) -> (FTCQueue m x b) -> ViewL m a b
	tviewl :: FTCQueue m a b -> ViewL m a b
```
FTCQueue m a b представляет композицию одной или более функций вида a -> m b. Операция tsingleton конструирует одно-элементную последовательность , (|>) добавляет новый элемент справа, а (|><|) сонкатенирует две последовательности. tviewl удаляет элемент слева. Все операции имеют постоянное или в среднем постоянное время выполнения. Наш FTCQueue можно рассматривать как упрощённый вариант более обобщённой, типо-ориентированной очереди из ранее упомянутой «Reflection without remorse…» (см. выше). Таким образом, композиция функций (сегменты продолжений) a -> Eff r t1, t1 -> Eff r t2, … tn -> Eff r b могут быть представлены как

```Haskell
type Arrs r a b = FTCQueue (Eff r) a b
```
и монада Eff r принимает следующий вид

```Haskell
data Eff r a where
	Pure :: a -> Eff r a
	Impure :: Union r x -> Arrs r x a -> Eff r a
```
Композиция функций сама является функцией, так что Arrs r a b изоморфизм к одной Arr r a b или a -> Eff r b. В одном направлении

```Haskell
singleK :: Arr r a b -> Arrs r a b
singleK = tsingleton
```
конверсия строит последовательность из одного элемента, В другом направлении

```Haskell
qApp :: Arrs r b w -> b -> Eff r w
qApp q x = case tviewl q of
	TOne k -> k x
	k :| t -> bind' (k x) t
      where bind' :: Eff r a -> Arrs r a b -> Eff r b
     	    bind' (Pure y) k = qApp k y
                  bind' (Impure u q) k = Impure u (q |><| k)
```
Операция qApp применяет аргумент x к композиции функций заданной последовательностью Arrs r b w. Точнее, она применяет x к голове последовательности k и «подшивает» хвост t (если он есть) таким же образом. Это преимущество в производительности нового представление продолжения. Операция bind' подобно монадной (>>=) но с представлением продолжениями как последовательность Arrs r a b вместо a -> Eff r b функции. Если применение k x выполняется за постоянное время, то целая qApp q x занимает, в среднем, постоянное время.

В заключении, монадный экземпляр Eff r

```Haskell
instance Monad (Eff r) where
	return = Pure
	Pure x >>= k = k x
	Impure u q >>= k = Impure u (q |> k)
```
связывая операции наращивает последовательность продолжений Arrs r x a добавляя новые сегменты k, что занимает постоянное время.

### 3.2  Демонстрация библиотеки: Определение и интерпретация (выполнение) эффектов

Сейчас мы продемонстрируем библиотеку расширяемых эффектов: напишем и объединим вычисления с эффектами при помощи монады Eff. Мы переделаем примеры reader и writer из пп.2.1 и 2.2 чтобы показать, что добавление следующего эффекта не требует внесения изменений в предыдущий.

Для эффекта Reader запрос просто спрашивает ответ типа i.

```Haskell
data Reader i x where
	Get :: Reader i i
```
Простейший клиент, что возвращает запрошенный ответ

```Haskell
ask :: Member (Reader i) r => Eff r i
ask = Impure (inj Get) (tsingleton Pure)
```
Повторим: tsingleton создаёт последовательность из одного элемента. Следующая библиотечная функция, посылающая запрос, даже проще:

```Haskell
send :: Member t r => t v -> Eff r v
send t = Impure (inj t) (tsingleton Pure)
```
Примеры из п.2.1 выражаются через ask и монадные операции:

```Haskell
addGet :: Member (Reader Int) r => Int -> Eff r Int
addGet x = ask >>= \i -> return (i+x)
addN :: Member (Reader Int) r => Int -> Eff r Int
addN n = foldl (>>>) return (replicate n addGet) 0
```
Их типы, конечно, стали более общими: addN имеет Reader эффект и может использоваться с другими эффектами.

При интерпретации Reader запроса сейчас нужно учитывать, что могут быть и другие запросы со своими интерпретаторами. Вот новая версия runReader из п2.1:

```Haskell
runReader :: i -> Eff (Reader i ': r ) a -> Eff r a
runReader i m = loop m where
	loop (Pure x) = return x
	loop (Impure u q) = case decomp u of
		Right Get -> loop $ qApp q i
		Left u -> Impure u (tsingleton (qComp q loop))
```
Сигнатура типа указывает что runReader i принимает Eff вычисление с Reader i эффектом и возвращает Eff вычисление без него. Эффект Reader i здесь обрабатывается, иначе инкапсулируется. Код, в самом деле, отвечает на Get запрос, отправляя другие запросы к другим интерпретаторам через ветку Left. Там мы добавляем продолжение ответа q с помощью функции qComp:

```Haskell
qComp :: Arrs r a b -> (Eff r b -> Eff r ' c) -> Arr r ' a c
qComp g h = h .  qApp g
```
Результирующее продолжение – это другой список меток эффектов r’ некоторые из которых может быть будут обработаны в интерпретаторе h.

Обобщённый обработчик запроса представлен в следующей функции, входящей в библиотеку:

```Haskell
handle_relay :: (a -> Eff r w) 
	-> (forall v. t v -> Arr r v w -> Eff r w) 
	-> Eff (t ': r ) a -> Eff r w
handle_relay ret _ (Pure x) = ret x
handle_relay ret h (Impure u q) = case decomp u of
	Right x -> h x k
	Left u -> Impure u (tsingleton k)
    where k = qComp q (handle_relay ret h)
```
Первые два аргумента handle_relay подобны return и bind. Интерпретатор reader эффекта может использовать эту функцию для упрощения

```Haskell
runReader i = handle_relay return (\ Get k -> k i )
```
Последняя часть сигнатуры handle_relay, Eff (t ': r ) a -> Eff r w, показывает, что метка t обработанного эффекта должна быть в начале списка меток эффектов r. В то время, как функции вроде addN из примера выше или примера rdwr (который будет дальше) используют r как множество эффектов без учёта порядка, обработчики навязывают порядок. Этот факт можно заметить уже в интерфейсе Union из п2.5: в сигнатурах inj и prj, эффекты представлены переменной типа r которая должна быть Member. Другими словами, decomp берёт коллекцию эффектов описанную списком с намеченным (к обработке. прим. переводчика) t в заголовке. 

Исходя из нашего опыта, это требование упорядоченности обработчиков не проблема. Но, это теоретически неудовлетворительно. Мы могли бы уйти от этого ограничения поиграв с типами Constraint, требуемые тогда аннотации типа сделали бы результат непрактичным. К сожалению, не видно какого либо удобного способа в Haskell навешивать ограничение класса по словарю.
(Implicit parameters позволяют что то похожее.)

Для выполнения Eff вычисления после всех эффектов нужен обработчик предоставляемый библиотекой

```Haskell
run :: Eff '[] a -> a
run (Pure x) = x
```
Вариант Impure здесь невозможен, так как объединение Union ‘[] пуст. Таким образом, мы можем выполнить addGet 1

```Haskell
run . runReader 10 $ addGet 1
```
	Добавим writer эффект с контекстным значением типа о:

```Haskell
data Writer o x where
	Put :: o -> Writer o ()
	tell :: Member (Writer o) r => o -> Eff r ()
	tell o = send $ Put o
```
Тип tell позволяет нам комбинировать любые вычисления с эффектами в Writer o эффектом. Вот пример reader-writer вычислений

```Haskell
-- rdwr :: (Member (Reader Int) r, Member (Writer String) r)
-- => Eff r Int
rdwr = do { tell "begin"; r <-  addN 10; tell "end"; return r g }
```
Вывод типа показан в комментариях. Поскольку тип addN полиморфен относительно r, мы можем использовать addN точно так же в вычислениях с большим числом эффектов (и это же касается tell).

В п2.2, интерпретатор для Reader-Writer вычислений был единым runRdWriter, который обрабатывал оба типа запроса. Сейчас мы можем интерпретировать отдельно только Writer запросы

```Haskell
runWriter :: Eff (Writer o ': r ) a -> Eff r (a,[o])
runWriter = 
	handle_relay (\x -> return (x,[]))
              		          (\(Put o) k -> k () >>= \(x,i) -> return (x, o:i))
```
И буквально объединять его с ранее написанным runReader. Пример reader-writer вычислений в функции rdwr выполняется теперь так

```Haskell
(run . runReader 10 . runWriter) rdwr
```
Т.к. эффекты reader и writer коммутативны, порядок интерпретаторов неважен, они могут быть переставлены без изменения результата.

Возможно написать другие reader и writer интерпретаторы, например, обрабатывая Reader и Writer запросы вместе, так, что последнее значение переданное в tall станет следующим которое возвратит Reader запрос. В этом случае мы получим реализацию State, разбитую на части чтения и изменения.

```Haskell
runStateR :: Eff (Writer s ': Reader s ': r ) w -> s -> Eff r (w,s)
runStateR m s = loop s m where
	loop :: s -> Eff (Writer s ': Reader s ': r ) w -> Eff r (w,s)
	loop s (Pure x) = return (x, s)
	loop s (Impure u q) = case decomp u of
		Right (Put o) -> k o ()
		Left u -> case decomp u of
			Right Get -> k s s
			Left u -> Impure u (tsingleton (k s))
    where k s = qComp q (loop s) 
```

### 3.3 Улучшение производительности

Этот пункт – повторный анализ производительности свободнейшей (freer) монады после изменения представления продолжения запросов на проблемном примере из п2.6. Как и ранее, addN 3 приводит к 

```Haskell
	((( return >>> addGet) >>> addGet) >>> addGet) 0
```
И затем к

```Haskell
 	(( Impure (inj Get) [ return >>> (+0)]) >>= addGet) >>= addGet
```
Или

```Haskell
	Impure (inj Get) [ return (+0), addGet, addGet]
```
(здесь мы используем списочную нотацию вместо упорядоченной по типу последовательности для упрощения). Пока процесс и его результат, кажется, похож на тот, что был с неоптимизированной монадой в п2.5. Тот факт, что продолжение Get запроса теперь представлено в виде эффективной последовательность даёт разницу. Когда интерпретатор runReader отвечает, скажем, значением v1, это даёт следующие операции, в конечном итоге производящие, новый запрос. Обратим внимание на t – остаток (хвост,tail) продолжения запроса (в нашем примере t – однозвенная последовательность [addGet]):

```Haskell
qApp (return (+0) : addGet : t) v1
{- т.е. -} return v1 `bind` (addGet : t)
{- т.е. -} addGet v1 `bind` t
{- т.е. -} Impure (inj Get) (return (+v1) : t)
```
Показанная выше редукция последовательности имеет дело только с двумя первыми продолжениями оригинального запроса. Остаток t даже не использовался. Кроме того, все FTCQueue операции с t, например, объединения и т.д., выполняются за постоянное время. Таким образом, вся последовательность сокращений выше выполняется за время независящее от длины t. Таким образом, время выполнения addN n линейно зависит от n. По сравнению с предыдущей версией п2.5, мы получаем алгоритмическое улучшение производительности от квадратичной к линейной. Ключ к производительности, это способность смотреть и удалять начальные сегменты собранных продолжений запросов. Если продолжение представлено как композиция функций, мы не можем «разобрать» их, - но мы может разобрать структуру данных.

## 4. Оценка эффективности

(не переведено)

## 5. Недетерминизм подверженный выбору

Недетерминизм, с встроенной балансировкой нескольких продолжений может показаться невозможно выразить через «свободнейшею» (freer) монаду, которая имеет дело с одним продолжением. Эта секция показывает что не только Eff монада может предоставлять недетерминированный выбор, но так же что такое представление сохраняет разделяемые продолжения, теряемые в обычной свободной монаде. Недетерминизм моделей свободной монады со следующим функтором запроса

```Haskell
data Ndet x = MZero | MPlus x x
instance Functor Ndet where ...
```
MZero, подобно исключению, обрывает запросы в текущей линии продолжений как неуспешные. 

MPlus спрашивает контекст для выбора между двумя Ndet продолжениями. Такая сигнатура запроса непосредственно следует из интерфейса недетерминированных вычислений в
Haskell: MonadPlus или Alternative:

```Haskell
instance MonadPlus (Free Ndet) where
	mzero = Impure MZero
	mplus m1 m2 = Impure $ MPlus m1 m2
```
Конструктор MPlus имеет два аргумента – продолжения. Как мы собираемся разделить их в один аргумент продолжения FFree? Рассмотрим недетерминированную выбор в контексте:

```Haskell
(mplus m1 m2 >>= k1) >>= k2
{- Связка монады Free -}
  Impure (fmap (>>= k1) (MPlus m1 m2) >>= k2
{- fmap из derived Functor -}
  Impure (MPlus (m1 >>= k1) (m2 >>= k1)) >>= k2
{- то же для k2 -}
  Impure (MPlus ((m1 >>= k1) >>= k2) ((m2 >>= k1) >>= k2))
```
То есть, два продолжения, собранные MPlus фактически имеют общее окончание K1, K2. Это окончание, хоть и общее, но не разделённое (not shared): хотя два продолжения Mplus разделяют общие сегменты, собраны они независимо. Именно это окончание «свободнейшая» (freer) монада будет выносить и разделять. После разделения окончания, оставшийся MPlus запрашивает контекст к просмотру и возвращает один из двух выборов. Нет необходимости включать сам выбор в запрос. Таким образом, с Еff, эффект недетерминизма имеет следующую сигнатуру:

```Haskell
data NdetEff a where
	MZero :: NdetEff a
	MPlus :: NdetEff Bool

instance Member NdetEff r => MonadPlus (Eff r) where
	mzero = send MZero
	mplus m1 m2 = send MPlus >>= \x -> if x then m1 else m2
```
Для полной реализации мы добавим интерпретатор, такой как следующий, отображающий NdetEff-эффект в недетерминированную Alternative:

```Haskell
makeChoiceA :: Alternative f => Eff (NdetEff ': r ) a -> Eff  r (f a)
makeChoiceA = handle_relay (return . pure) $ \m k -> case m of
	MZero -> return empty
	MPlus -> liftM2 (<|>) (k True) (k False)
```
Преимущество отображения NdetEff через Alternative не только даёт возможность смешивать NdetEff с другими (не аппликативными) эффектами, к примеру, State. Это так же поддерживает, так называемый “committed choice” (преданный выбор), так же как логика if-then-else (называемая  “soft-cut” в Prolog):

```Haskell
ifte :: Member NdetEff r => Eff r a 
			-> (a -> Eff r b) 
			-> Eff r b 
			-> Eff r b
```
Декларативно, ifte t th el эквивалентно t >>= th если недетерминированное вычисление t успешно хотя бы однажды. Иначе ifte t th el эквивалентно el. Различие между ifte t th el и, казалось бы, эквивалентным (t>>=th) `mplus` el в том, что в последнем el - является валидным выбором, даже если т успешно. А в случае ifte, el выбирается, если, и только если t – failure. Один из примеров применения ifte – парсер с множеством комбинаторов «максимально разжёвывающий» (‘maximal munch’) : при многих пробах необходимо сохранять аргумент парсера p как можно дольше. Другой, хотя и более надуманный пример, но более легкий для объяснения: вычисление простых чисел.

```Haskell
test_ifte = do
	n <-  gen
	ifte  ( do 
		d <-  gen
		guard $ d <n && n `mod` d == 0)
	       (\_ -> mzero)
	       (return n)
  where	gen = msum . fmap return $ [2..30]
              msum :: MonadPlus m => [m a] -> m a – выбор из списка
```
Здесь недетерминированно генерируются кандидат делимое и кандидат делитель. Кандидат в простые числа проходит, если все попытки разделить его неудачны. Например

```Haskell
test_ifte_run :: [ Int ]
test_ifte_run = run .  makeChoiceA $ test_ifte
-- [2,3,5,7,11,13,17,19,23,29]
```
Мы сделали не только ifte, но и более общий 

```Haskell
msplit :: Member NdetEff r => Eff r a -> Eff  r (Maybe (a, Eff r a))
```
Можно думать о msplit, как о проверяющем вычисление аргумента на возможность вычисления. Если вычисление дает ответ, он возвращается вместе с вычислениями, которые могут дать дополнительные ответы. Реализация столь проста и мала, что может быть приведена в полном объеме:

```Haskell
msplit = loop [] where
	loop jq (Pure x) = return (Just (x, msum jq))
	loop jq (Impure u q) = case prj u of
		-- Текущий выбор провален (запрос отмены).
		 Just MZero -> case jq of
			-- Проверяем, есть ли другие варианты
			[] -> return Nothing
			(j : jq ) -> loop jq j
		Just MPlus -> loop ((qApp q False): jq ) (qApp q True)
		_ -> Impure u (tsingleton k) where k = qComp q (loop jq)
```
По простому, msplit t перехватывает NdetEff запросы t. Если t требуется выбор, MPlus, один выбор обрабатывается, а другой сохраняется в рабочем списке возможных выборов jq. Функция завершается, когда обнаруживается успешное вычисление (рабочий список – это коллекция оставшихся вариантов), или когда все варианты перебраны.

## 6. Ловля IO исключений

Обработка IO ошибок в присутствии других эффектов изобилует тонкостями. Поэтому считалось, что это проблема для Eff библиотеки. Не только для Eff, но и для mtl. C «расширяемыми эффектами» состояние вычисления в точке исключения доступно обработчику. В mtl обработчик исключения получает доступ к состоянию что существовало в точке где было установлено (в месте вызова catch). Любые дальнейшие изменения, вплоть до точка за исключением, будут потеряны. Захват ошибок ввода-вывода в общих вычислений с монадой MonadIO (не только с одной MonadIO) имел свои особенности возвращая нас в 2003 г. В дальнейшем, подход был усовершенствован во многих пакетах (таких как MonadCatchIO) и, в конце концов, де-факто стандартизирован в exceptions. Решение, несмотря на, его весьма полезность во многих случаях, не без проблем. Для примера, рассмотрим следующее вычисление с Writer и IO эффектами

```Haskell
do tell "begin"; r  <- faultyFn; tell "end"; return r `catch` (\e -> return .  show $ (e:: SomeException))
```
здесь faultyFn бросает или IO, или определённое пользователем динамическое исключение. С mtl, любые обновления состояния Writer от catch к точке обработки теряются. В коде выше, не запишутся ни  "end", ни "begin". 

Для понимания mtl поведения вспомним, что WriterT String IO a возвращает IO (a,String): это вычисление, которое производит значение вместе с результатом Writer. Функция catch реализована так (см. liftCatch в mtl):

```Haskell
catch h m = m `IO.catch` \e -> h e
```
Когда IO исключение случается, значение, произведённое m, включая Writer теряются. liftCatch из mtl для монады State просто сбрасывает состояние, накопленное до входа в catch. В общем случае, взаимодействие эффектов в mtl зависит от порядка слоёв трансформеров. IO монада не может быть трансформером и должна всегда быть внизу стека.

Если мы выполним тот же код с обработкой ошибок IO в  нашей библиотеке, то, в трассируемые события, конечно, не запишется "end", но запишется "begin".  

```Haskell
catchDynE :: forall e a r . (MemberU2 Lift (Lift IO) r , Exc.Exception e) ) 
	=> Eff r a -> (e -> Eff r a) -> Eff r a
catchDynE m eh = interpose return h m
	where
		h :: Lift IO v -> Arr r v a -> Eff r a
		h (Lift em) k = lift (Exc.try em) >>= \x -> case x of
			Right x -> k x
			Left e -> eh e
```
В «extensible effects library» IO вычисления требуют Lift IO эффекта

```Haskell
newtype Lift m a = Lift (m a)
```
и своего интерпретатора

```Haskell
runLift :: Monad m => Eff '[Lift m] w -> m w
```
Если он требуется, необходимо специальное ограничение в сигнатуре - MemberU2 Lift (Lift IO) r

В библиотеки, для этого случая, предусмотрена функция interpose – версия handle_relay что не использует обработчик эффекта, хотя и отвечает на запрос: interpose может, так же повторно бросить (‘re-throw’) запрос эффекта. Функция catchDynE перехватывает IO запросы оборачивая их в Exception.try. Поэтому ошибки IO мгновенно ловятся и не происходит отмена их продолжений. Обработчики эффектов не теряют состояние. Поэтому мы можем легко реализовать поведение транзакций: на исключение выполняется откат (rolling-back) состояния на то, что было, когда обработчик исключений был установлен. Смотрите исходный код для подробной информации.

## 7. Регионы

Монадические регионы были введены Fluet и Morrisett, как удивительно простой вариант типобезопасного управления областями памяти системы. Это можно рассматривать как вложенной ST монады, также поддерживающие ссылочные ячейки в родительском регионе, которые могут, относительно беспроблемно,  использоваться в любом регионе - потомке. Легкие монадические регионы является реализацией в Haskell расширенной версии из Fluet и Morrisett система, которая поддерживает, так же, и IO ресурсы, такие, как дескрипторы файлов, а не только ячейки памяти, а проста в использовании. Легкие регионы статически гарантируют, что каждый доступный FileHandle является открытым, в то время как своевременное закрытие, так же, обеспечивается. Оригинальные монадические регионы, используют атомарную монаду, индексируемую по уникальному имени региона. Облегчённая версия, построен на итерации ST-подобной монады-трансформера. Настоящая библиотека «Extensible effects» с атомарной Eff монадой, индексируемой по эффектам хорошо подходит для новой реализации облегчённой версии регионов Fluet и Morrisett-а в оригинальном стиле, избегая неудобств обхода отношений родитель-потомок. Чтобы гарантировать, что выделенный ресурс, такой как ячейка памяти или file handle не покинет своего региона, монадические регионы - как монада St s - отмечают типы вычисления и его ресурсы с количественной (или rigid (жёсткой), в терминах GHC) типе переменной. Использование Typeable для таких типов напрашивается первым. Больше всего беспокоит, любое программирования на уровне типов, с типами, которые включают в себя жесткие (rigid) переменные никогда не создаст хрупкий экземпляр. Иногда, incoherent instances необходимы, что является довольно тревожным, так как такие расширения мы стремимся избегать. Наконец, легкие монадические регионы, хотя и основаны на монадных трансформерах, намеренно запрещают любые lift и, следовательно, добавление других эффектов. Все эти проблемы были решены. Ниже мы рассмотрим основные моменты реализации. 

Так как новая версия «extensible effects» больше не использует Typeable, то первая проблема пропала. Со второй сложнее. Большинство реализаций идеи Fluet и Morrisett предполагают RegionEff s эффект индексированный rigid типом переменной s которая является именем региона. Дескрипторы файла, выделеные в регионе будут отмечены его именем региона:

```Haskell
newtype SHandle s = SHandle Handle
data RegionEff s a where
	RENew :: FilePath -> IOMode -> RegionEff s (SHandle s)
```
Конструкторы данных приватны и не экспортируются. (Настоящая реализация несколько более сложна).
	Операция создания нового файлового дескриптора будет посылать RENew запрос и предполагать обработчик, маркированный по имени региона.

```Haskell
newSHandle :: Member (RegionEff s) r => -- простейший
	FilePath -> IOMode -> Eff r (SHandle s)
newSHandle fname fmode = send (RENew fname fmode)
```
Список ограничений несколько упрощён, опущено вычисление уровня типа что сканирует список эффектов с меткой r и находит имя ближайшей, то есть внутренней, области. 

Интерпретатор запросов:

```Haskell
newRgn :: (forall s. Eff (RegionEff  s ': r ) a) -> Eff r a
```
подобно runST, имеет высоко ранговый тип: неформально, он выделяет свежую жёсткого типа переменную s со свежим именем региона. Интерпретатор хранит список обработчиков, запрошенных при выделениях (аллокациях) и закрывает все при нормальном или по исключению завершении. Операция использует обработчик типа

```Haskell
shGetLine :: Member (RegionEff s) r => SHandle s -> Eff r String
```
который обеспечивает соблюдение, чтобы область владеющяя обработчиком была активной.

Кстати, сигнатура автоматически позволяет использовать обработчик эффекта выделенный в области предка в области потомка. Наметившаяся реализация действительно работает, за исключением двух тонкостей. Заманчиво думать о жесткой переменной типа s в качестве названия для области RegionEff s. Увы, даже присутствие ограничения Member (RegionEff s) r, проверка что эффект  RegionEff s есть часть текущего списка эффектов r, не поможет различить два типа RegionEff s1 и RegionEff s2 которые отличаются только жёстким типом переменной. Хотя эти переменные никогда не станут экземпляром, и, следовательно, никогда не смогут быть теми же самыми, система разрешения ограничений GHC (the constraint-solving part of GHC)  незнает или не понимает этого факта. Таким образом, мы должны дать регионам другие имена - type-level numeral, которые система разрешения ограничений сможет различить. Поэтому, сигнатуры newSHandle и newRgn (но не shGetline, и т.д.) немного более сложны, чем показано. 

Вторая тонкость позволяет использовать другие эффекты помимо RegionEff. Поскольку все возможные эффекты Eff r вычислениий перечислены в списке r, мы просто должны посмотреть список, чтобы проверить, если такой подходящий эффект. Реализация предлагает ограничение SafeForRegion, которое трактует Reader и State как безопасные. Exc SomeException так же возможно, так как newRgn специально прослушивает этот запрос. Остальная часть реализации проста. Она проходит регрессионные тесты старых Lightweight Regions с минимальными изменениями.
	
## 8. Related Work (материалы, связанные с работой)

(не переведено)

## 9. Выводы

(не переведено)

## Благодарности

(не переведено)

## Ссылки

(не переведено)

